peterson算法做到了什么
    perterson算法借助共享内存和对变量的原子操作，实现了两个对临界区的访问满足三个条件：
    1.互斥（没有两个进程同时访问临界区）
    2.有限等待（不会产生饥渴，进程等待锁最多一轮）
    3.前进（当没有进程处于临界区时，可以进入）

如何实现的
    1.想要获得锁,Flag[i]=1表示i想要得到锁
    2.谦让地上锁,总是让对方获得锁(我的理解就是先谦让的进程先获得锁，比如1先表明想要锁，然后谦让给了0,自己进入忙等，
        此时0表明后，又谦让给了1，进入忙等，而忙等中的0发现对方又谦让了回来，就进入临界区了，因此谦让的代码已经执行过了．

Flag和turn都必须吗？
    如果只有Flag，那么当可能产生饥渴，因为只要锁不在对方身上，就会去上锁，也就是哪个线程先设置flag=true,哪个线程
        就有获得锁，因此会产生饥渴
    如果只有turn,就成为两个线程交替执行，那么执行快的线程进入临界区必须等待慢的，就像两个销售，共享一个总销售额变量，
        如果一个销售效率高，很快就完成一笔订单，那她修改共享变量还得等待慢地，这也不合理．销售效率高的人可能会连续访问
        共享变量，这不代表慢的产生饥渴，因为慢的此时还在其他区，而非在等待锁．
